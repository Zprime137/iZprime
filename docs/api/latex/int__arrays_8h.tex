\doxysection{include/\+int\+\_\+arrays.h File Reference}
\hypertarget{int__arrays_8h}{}\label{int__arrays_8h}\index{include/int\_arrays.h@{include/int\_arrays.h}}


Dynamic arrays for uint16\+\_\+t, uint32\+\_\+t, and uint64\+\_\+t values.  


{\ttfamily \+\#include $<$utils.\+h$>$}\newline
\doxysubsubsection*{Data Structures}
\begin{DoxyCompactItemize}
\item 
struct \doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}}
\begin{DoxyCompactList}\small\item\em Dynamic array for uint16\+\_\+t values. \end{DoxyCompactList}\item 
struct \doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}}
\begin{DoxyCompactList}\small\item\em Dynamic array for uint32\+\_\+t values. \end{DoxyCompactList}\item 
struct \doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}}
\begin{DoxyCompactList}\small\item\em Dynamic array for uint64\+\_\+t values. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Functions}
\begin{DoxyCompactItemize}
\item 
int \doxymbox{\hyperlink{group__iz__arrays_ga3243610d8f1b9c7cd225dc0d7f80323e}{TEST\+\_\+\+GENERIC\+\_\+\+INT\+\_\+\+ARRAYS}} (int verbose)
\begin{DoxyCompactList}\small\item\em Run generic dispatch tests for C11 \+\_\+\+Generic helper macros. \end{DoxyCompactList}\end{DoxyCompactItemize}
\begin{Indent}\textbf{ UI16 API}\par
\begin{DoxyCompactItemize}
\item 
\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*} {\bfseries ui16\+\_\+init} (int capacity)
\begin{DoxyCompactList}\small\item\em Allocate a UI16 array with an initial capacity. \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+free} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Free a UI16 array and null the caller pointer. \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+resize\+\_\+to} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, int new\+\_\+capacity)
\begin{DoxyCompactList}\small\item\em Resize UI16 storage to {\ttfamily new\+\_\+capacity} (must be \texorpdfstring{$>$}{>}= count). \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+resize\+\_\+to\+\_\+fit} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Shrink UI16 storage so capacity equals count. \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+push} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, uint16\+\_\+t element)
\begin{DoxyCompactList}\small\item\em Append a uint16 value, growing storage if needed. \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+sort} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Sort values in ascending order. \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+pop} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Remove the last element if the array is non-\/empty. \end{DoxyCompactList}\item 
void {\bfseries ui16\+\_\+compute\+\_\+hash} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Compute SHA-\/256 checksum over active payload. \end{DoxyCompactList}\item 
int {\bfseries ui16\+\_\+verify\+\_\+hash} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Verify the stored checksum against current payload. \end{DoxyCompactList}\item 
int {\bfseries ui16\+\_\+fwrite} (\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, FILE \texorpdfstring{$\ast$}{*}file)
\begin{DoxyCompactList}\small\item\em Serialize count, payload, and checksum to a binary stream. \end{DoxyCompactList}\item 
\doxymbox{\hyperlink{struct_u_i16___a_r_r_a_y}{UI16\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*} {\bfseries ui16\+\_\+fread} (FILE \texorpdfstring{$\ast$}{*}file)
\begin{DoxyCompactList}\small\item\em Deserialize a UI16 array from a binary stream. \end{DoxyCompactList}\item 
int {\bfseries TEST\+\_\+\+UI16\+\_\+\+ARRAY} (int verbose)
\begin{DoxyCompactList}\small\item\em Execute UI16 test suite. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ UI32 API}\par
\begin{DoxyCompactItemize}
\item 
\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*} {\bfseries ui32\+\_\+init} (int capacity)
\begin{DoxyCompactList}\small\item\em Allocate a UI32 array with an initial capacity. \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+free} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Free a UI32 array and null the caller pointer. \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+resize\+\_\+to} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, int new\+\_\+capacity)
\begin{DoxyCompactList}\small\item\em Resize UI32 storage to {\ttfamily new\+\_\+capacity} (must be \texorpdfstring{$>$}{>}= count). \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+resize\+\_\+to\+\_\+fit} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Shrink UI32 storage so capacity equals count. \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+push} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, uint32\+\_\+t element)
\begin{DoxyCompactList}\small\item\em Append a uint32 value, growing storage if needed. \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+sort} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Sort values in ascending order. \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+pop} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Remove the last element if the array is non-\/empty. \end{DoxyCompactList}\item 
void {\bfseries ui32\+\_\+compute\+\_\+hash} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Compute SHA-\/256 checksum over active payload. \end{DoxyCompactList}\item 
int {\bfseries ui32\+\_\+verify\+\_\+hash} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Verify the stored checksum against current payload. \end{DoxyCompactList}\item 
int {\bfseries ui32\+\_\+fwrite} (\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, FILE \texorpdfstring{$\ast$}{*}file)
\begin{DoxyCompactList}\small\item\em Serialize count, payload, and checksum to a binary stream. \end{DoxyCompactList}\item 
\doxymbox{\hyperlink{struct_u_i32___a_r_r_a_y}{UI32\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*} {\bfseries ui32\+\_\+fread} (FILE \texorpdfstring{$\ast$}{*}file)
\begin{DoxyCompactList}\small\item\em Deserialize a UI32 array from a binary stream. \end{DoxyCompactList}\item 
int {\bfseries TEST\+\_\+\+UI32\+\_\+\+ARRAY} (int verbose)
\begin{DoxyCompactList}\small\item\em Execute UI32 test suite. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}
\begin{Indent}\textbf{ UI64 API}\par
\begin{DoxyCompactItemize}
\item 
\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*} {\bfseries ui64\+\_\+init} (int capacity)
\begin{DoxyCompactList}\small\item\em Allocate a UI64 array with an initial capacity. \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+free} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}\texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Free a UI64 array and null the caller pointer. \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+resize\+\_\+to} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, int new\+\_\+capacity)
\begin{DoxyCompactList}\small\item\em Resize UI64 storage to {\ttfamily new\+\_\+capacity} (must be \texorpdfstring{$>$}{>}= count). \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+resize\+\_\+to\+\_\+fit} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Shrink UI64 storage so capacity equals count. \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+push} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, uint64\+\_\+t element)
\begin{DoxyCompactList}\small\item\em Append a uint64 value, growing storage if needed. \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+sort} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Sort values in ascending order. \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+pop} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Remove the last element if the array is non-\/empty. \end{DoxyCompactList}\item 
void {\bfseries ui64\+\_\+compute\+\_\+hash} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Compute SHA-\/256 checksum over active payload. \end{DoxyCompactList}\item 
int {\bfseries ui64\+\_\+verify\+\_\+hash} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array)
\begin{DoxyCompactList}\small\item\em Verify the stored checksum against current payload. \end{DoxyCompactList}\item 
int {\bfseries ui64\+\_\+fwrite} (\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*}array, FILE \texorpdfstring{$\ast$}{*}file)
\begin{DoxyCompactList}\small\item\em Serialize count, payload, and checksum to a binary stream. \end{DoxyCompactList}\item 
\doxymbox{\hyperlink{struct_u_i64___a_r_r_a_y}{UI64\+\_\+\+ARRAY}} \texorpdfstring{$\ast$}{*} {\bfseries ui64\+\_\+fread} (FILE \texorpdfstring{$\ast$}{*}file)
\begin{DoxyCompactList}\small\item\em Deserialize a UI64 array from a binary stream. \end{DoxyCompactList}\item 
int {\bfseries TEST\+\_\+\+UI64\+\_\+\+ARRAY} (int verbose)
\begin{DoxyCompactList}\small\item\em Execute UI64 test suite. \end{DoxyCompactList}\end{DoxyCompactItemize}
\end{Indent}


\doxysubsection{Detailed Description}
Dynamic arrays for uint16\+\_\+t, uint32\+\_\+t, and uint64\+\_\+t values. 

The module provides uniform typed arrays with append/\+pop operations, deterministic resizing, optional SHA-\/256 integrity checks, and binary I/\+O. 

Definition in file \doxymbox{\hyperlink{int__arrays_8h_source}{int\+\_\+arrays.\+h}}.

